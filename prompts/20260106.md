# Django データベース操作とブログアプリ実装（2026/01/06）

このドキュメントは、Djangoでのデータベース操作、テスト、Generic Viewsの使い方について学んだ内容をまとめたものです。

## 目次
1. [データベース基礎](#1-データベース基礎)
2. [シーディング（テストデータ投入）](#2-シーディングテストデータ投入)
3. [テスト](#3-テスト)
4. [実装したファイル](#4-実装したファイル)
5. [トラブルシューティング](#5-トラブルシューティング)
6. [Django Generic Views](#6-django-generic-views)

---

## 1. データベース基礎

### 1.1 接続先の指定方法

**settings.py での設定:**
```python
# SQLite3（デフォルト）
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}

# PostgreSQL
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': 'mydb',
        'USER': 'myuser',
        'PASSWORD': 'mypassword',
        'HOST': 'localhost',
        'PORT': '5432',
    }
}
```

**接続確認コマンド:**
```bash
# データベースシェル起動
python manage.py dbshell

# Pythonシェルから確認
python manage.py shell
>>> from django.db import connection
>>> cursor = connection.cursor()
>>> cursor.execute("SELECT 1")
>>> print("Database connection OK!")
```

### 1.2 スキーマの定義とマイグレーション

**アプリケーション作成:**
```bash
python manage.py startapp blog

# settings.py の INSTALLED_APPS に追加が必須
INSTALLED_APPS = [
    ...
    'blog',  # これを追加
]
```

**重要:** `makemigrations` は `INSTALLED_APPS` に登録されたアプリの `models.py` のみを見ます。登録しないとマイグレーションが作成されません。

**モデル定義例（models.py）:**
```python
from django.db import models
from django.contrib.auth.models import User

class Category(models.Model):
    name = models.CharField(max_length=100, unique=True)
    description = models.TextField(blank=True)
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    
    class Meta:
        ordering = ['name']
    
    def __str__(self):
        return self.name

class Post(models.Model):
    STATUS_CHOICES = [
        ('draft', '下書き'),
        ('published', '公開済み'),
    ]
    
    title = models.CharField(max_length=200)
    slug = models.SlugField(unique=True)
    author = models.ForeignKey(User, on_delete=models.CASCADE, related_name='posts')
    category = models.ForeignKey(Category, on_delete=models.SET_NULL, null=True, related_name='posts')
    content = models.TextField()
    status = models.CharField(max_length=10, choices=STATUS_CHOICES, default='draft')
    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)
    published_at = models.DateTimeField(null=True, blank=True)
    
    class Meta:
        ordering = ['-created_at']
        indexes = [
            models.Index(fields=['slug']),
            models.Index(fields=['status', '-published_at']),
        ]
```

**マイグレーションコマンド:**
```bash
# マイグレーションファイル作成
python manage.py makemigrations blog

# マイグレーション適用
python manage.py migrate blog

# 状態確認
python manage.py showmigrations

# SQL確認
python manage.py sqlmigrate blog 0001
```

**ロールバック:**
```bash
# 特定のマイグレーションまで戻る
python manage.py migrate blog 0001

# すべて取り消し
python manage.py migrate blog zero
```

### 1.3 N+1問題を避けたCRUD操作

**N+1問題とは:**
- 一覧取得: 1回のクエリ
- 各レコードの関連データ取得: N回のクエリ
- 合計: N+1回（パフォーマンス問題）

**解決方法:**

**select_related() - 1対1、多対1（JOIN使用）:**
```python
# ❌ BAD: N+1問題
posts = Post.objects.all()
for post in posts:
    print(post.author.username)  # 各投稿ごとにクエリ

# ✅ GOOD: 1回のJOIN
posts = Post.objects.select_related('author', 'category').all()
for post in posts:
    print(post.author.username)  # キャッシュから取得
```

**prefetch_related() - 多対多、逆参照（別クエリで一括取得）:**
```python
# ❌ BAD: N+1問題
posts = Post.objects.all()
for post in posts:
    print(post.comments.count())  # 各投稿ごとにクエリ

# ✅ GOOD: 別クエリで一括取得
posts = Post.objects.prefetch_related('comments', 'tags').all()
for post in posts:
    print(post.comments.count())  # キャッシュから取得

# Prefetchで詳細制御
from django.db.models import Prefetch
posts = Post.objects.prefetch_related(
    Prefetch('comments', queryset=Comment.objects.select_related('author'))
).all()
```

**トランザクション:**
```python
from django.db import transaction

# デコレータ形式
@transaction.atomic
def create_post_with_comments(title, content, comment_texts):
    post = Post.objects.create(title=title, ...)
    for text in comment_texts:
        Comment.objects.create(post=post, content=text)
    return post

# コンテキストマネージャ形式
def update_post(post_id, new_title):
    with transaction.atomic():
        post = Post.objects.select_for_update().get(id=post_id)  # 悲観的ロック
        post.title = new_title
        post.save()
```

**実行クエリの確認:**
```python
from django.db import connection, reset_queries

reset_queries()
# ... クエリ実行 ...
print(len(connection.queries), "queries")
for query in connection.queries:
    print(query['sql'])
```

### 1.4 Scaffold機能（Django Admin）

DjangoにはRailsのような`scaffold`コマンドはありませんが、管理画面が非常に強力です。

**admin.py での登録:**
```python
from django.contrib import admin
from .models import Category, Post, Comment

# シンプルな登録
admin.site.register(Category)

# カスタマイズした登録
@admin.register(Post)
class PostAdmin(admin.ModelAdmin):
    list_display = ['title', 'author', 'status', 'created_at']
    list_filter = ['status', 'category', 'created_at']
    search_fields = ['title', 'content']
    prepopulated_fields = {'slug': ('title',)}
    date_hierarchy = 'created_at'
    
    # インライン編集
    inlines = [CommentInline]
    
    # カスタムアクション
    @admin.action(description='選択した投稿を公開する')
    def make_published(self, request, queryset):
        updated = queryset.update(status='published')
        self.message_user(request, f'{updated}件の投稿を公開しました。')

# インライン定義（PostAdminより前に配置）
class CommentInline(admin.TabularInline):
    model = Comment
    extra = 1
```

**管理画面アクセス:**
```bash
# スーパーユーザー作成
python manage.py createsuperuser

# 開発サーバー起動
python manage.py runserver

# ブラウザで http://localhost:8000/admin/ にアクセス
```

---

## 2. シーディング（テストデータ投入）

Djangoには複数のシーディング方法があります。

### 2.1 Fixtures（JSON/YAML）

```bash
# データをエクスポート
python manage.py dumpdata blog.Category > blog/fixtures/categories.json

# データをインポート
python manage.py loaddata categories.json
```

### 2.2 カスタムマネジメントコマンド（推奨）

**blog/management/commands/seed_data.py:**
```python
from django.core.management.base import BaseCommand
from blog.models import Category, Post
from django.contrib.auth.models import User

class Command(BaseCommand):
    help = 'データベースにテストデータを投入します'
    
    def add_arguments(self, parser):
        parser.add_argument('--clear', action='store_true', 
                          help='既存データを削除してから投入')
    
    def handle(self, *args, **options):
        if options['clear']:
            Post.objects.all().delete()
            Category.objects.all().delete()
        
        # ユーザー作成
        user, created = User.objects.get_or_create(
            username='admin',
            defaults={'email': 'admin@example.com'}
        )
        if created:
            user.set_password('admin123')
            user.save()
        
        # カテゴリ作成
        tech = Category.objects.get_or_create(name='Technology')[0]
        
        # 投稿作成
        Post.objects.get_or_create(
            title='First Post',
            defaults={'author': user, 'category': tech, 'content': '...'}
        )
        
        self.stdout.write(self.style.SUCCESS('✓ データ投入完了'))
```

**実行:**
```bash
python manage.py seed_data --clear
```

### 2.3 データマイグレーション

```bash
python manage.py makemigrations --empty blog
```

生成されたファイルを編集：
```python
from django.db import migrations

def seed_data(apps, schema_editor):
    Category = apps.get_model('blog', 'Category')
    Category.objects.create(name='Technology')

class Migration(migrations.Migration):
    dependencies = [('blog', '0001_initial')]
    operations = [migrations.RunPython(seed_data)]
```

---

## 3. テスト

### 3.1 基本的なテスト実行

```bash
# すべてのテスト
python manage.py test

# 特定のアプリ
python manage.py test blog

# 特定のクラス
python manage.py test blog.tests.PostModelTest

# 特定のメソッド
python manage.py test blog.tests.PostModelTest.test_create_post

# 詳細表示
python manage.py test --verbosity=2
```

### 3.2 モデルの単体テスト

```python
from django.test import TestCase
from django.contrib.auth.models import User
from blog.models import Category, Post

class PostModelTest(TestCase):
    @classmethod
    def setUpTestData(cls):
        """全テストで1回だけ実行（パフォーマンス向上）"""
        cls.user = User.objects.create_user('testuser', password='pass')
        cls.category = Category.objects.create(name='Tech')
    
    def setUp(self):
        """各テスト前に実行"""
        self.post = Post.objects.create(
            title='Test Post',
            slug='test-post',
            author=self.user,
            category=self.category,
            content='Content',
            status='draft'
        )
    
    def test_post_creation(self):
        """投稿が正しく作成されるかテスト"""
        self.assertEqual(self.post.title, 'Test Post')
        self.assertEqual(self.post.author, self.user)
    
    def test_slug_uniqueness(self):
        """スラッグの一意性制約テスト"""
        from django.db import IntegrityError
        with self.assertRaises(IntegrityError):
            Post.objects.create(
                title='Another',
                slug='test-post',  # 重複
                author=self.user
            )
```

### 3.3 ビューの結合テスト

```python
from django.test import TestCase, Client
from django.urls import reverse

class PostListViewTest(TestCase):
    def test_view_url_exists(self):
        """URLが正しくアクセスできるか"""
        response = self.client.get('/blog/')
        self.assertEqual(response.status_code, 200)
    
    def test_view_uses_correct_template(self):
        """正しいテンプレートを使用しているか"""
        response = self.client.get('/blog/')
        self.assertTemplateUsed(response, 'blog/post_list.html')
    
    def test_only_published_posts_shown(self):
        """公開済み投稿のみ表示されるか"""
        response = self.client.get('/blog/')
        for post in response.context['posts']:
            self.assertEqual(post.status, 'published')

class PostCreateViewTest(TestCase):
    def test_login_required(self):
        """ログインが必要か"""
        response = self.client.get('/blog/create/')
        self.assertEqual(response.status_code, 302)  # リダイレクト
    
    def test_create_post_with_valid_data(self):
        """有効なデータで記事を作成できるか"""
        self.client.login(username='testuser', password='pass')
        data = {
            'title': 'New Post',
            'slug': 'new-post',
            'content': 'Content',
            'status': 'draft'
        }
        response = self.client.post('/blog/create/', data)
        self.assertEqual(response.status_code, 302)
        self.assertTrue(Post.objects.filter(slug='new-post').exists())
```

### 3.4 カバレッジ測定

```bash
pip install coverage

coverage run --source='.' manage.py test
coverage report
coverage html  # HTMLレポート生成
```

---

## 4. 実装したファイル

このセッションで実装した完全なブログアプリケーションの構成：

### 4.1 モデル層
- **blog/models.py** - Category, Post, Comment, Tag モデル
  - 外部キー、多対多、インデックス設定
  - ビジネスロジック（publish()メソッド）

### 4.2 管理画面
- **blog/admin.py** - Django Admin設定
  - カスタマイズした一覧表示
  - インライン編集
  - カスタムアクション

### 4.3 ビュー層
- **blog/views.py** - N+1対策済みビュー
  - PostListView, PostDetailView（表示）
  - PostCreateView, PostUpdateView, PostDeleteView（CRUD）
  - CategoryListView（集計）
  - APIビュー（JSON）
  - トランザクション使用例

### 4.4 URLルーティング
- **blog/urls.py** - URLパターン定義
  - 固定パスを先に、可変パスを後に配置（重要！）
  - 名前空間（app_name = 'blog'）設定
- **poc/urls.py** - プロジェクト全体のURL統合
  - `include('blog.urls')` で統合

### 4.5 テンプレート
- **templates/base.html** - ベーステンプレート
- **blog/templates/blog/post_list.html** - 記事一覧
- **blog/templates/blog/post_detail.html** - 記事詳細
- **blog/templates/blog/post_form.html** - 作成・編集フォーム
- **blog/templates/blog/post_confirm_delete.html** - 削除確認
- **blog/templates/blog/category_list.html** - カテゴリ一覧

### 4.6 テスト
- **blog/tests.py** - 包括的なテストスイート
  - モデルテスト（単体）
  - ビューテスト（結合）
  - APIテスト

### 4.7 シーディング
- **blog/management/commands/seed_data.py** - テストデータ投入コマンド
  - ユーザー、カテゴリ、タグ、投稿、コメント作成
  - `--clear` オプションで既存データ削除

### 4.8 ドキュメント
- **app/poc/DATABASE_GUIDE.md** - データベース操作の完全ガイド
  - 接続確認、マイグレーション、CRUD、トランザクション
  - N+1対策、管理画面、トラブルシューティング

---

## 5. トラブルシューティング

### 5.1 admin.E104エラー

**エラー:**
```
<class 'blog.admin.PostAdmin'>: (admin.E104) 'blog.PostAdmin' must inherit from 'InlineModelAdmin'.
```

**原因:**
```python
# ❌ BAD
inlines = ['CommentInline']  # 文字列で指定

# ❌ BAD
class PostAdmin(admin.ModelAdmin):
    inlines = [CommentInline]  # CommentInlineがまだ定義されていない

class CommentInline(admin.TabularInline):  # PostAdminの後に定義
    ...
```

**解決:**
```python
# ✅ GOOD: InlineをPostAdminより前に定義し、クラスを直接指定
class CommentInline(admin.TabularInline):
    model = Comment
    extra = 1

@admin.register(Post)
class PostAdmin(admin.ModelAdmin):
    inlines = [CommentInline]  # クラスを直接指定
```

### 5.2 URLルーティングの順序問題

**問題:** `/blog/create/` にアクセスすると404エラー

**原因:**
```python
# ❌ BAD: 可変パスが先
urlpatterns = [
    path('<slug:slug>/', views.PostDetailView.as_view()),  # これが先
    path('create/', views.PostCreateView.as_view()),        # マッチしない
]
```

**DjangoのURLルーティング:**
- **上から順に評価され、最初にマッチしたものが使われる**
- `create` が `<slug:slug>` にマッチしてしまう

**解決:**
```python
# ✅ GOOD: 固定パスを先に、可変パスを後に
urlpatterns = [
    path('', views.PostListView.as_view()),
    path('create/', views.PostCreateView.as_view()),        # 固定パスを先に
    path('categories/', views.CategoryListView.as_view()),  # 固定パスを先に
    path('<slug:slug>/', views.PostDetailView.as_view()),   # 可変パスは最後
]
```

### 5.3 Reverse for 'post_list' not foundエラー

**エラー:**
```
Reverse for 'post_list' not found. 'post_list' is not a valid view function or pattern name.
```

**原因:** 名前空間の指定漏れ

```python
# blog/urls.py
app_name = 'blog'  # 名前空間を設定している

# blog/views.py
success_url = reverse_lazy('post_list')  # ❌ 名前空間なし
```

**解決:**
```python
# ✅ GOOD: 名前空間を含める
success_url = reverse_lazy('blog:post_list')

# テンプレートでも同様
{% url 'blog:post_list' %}
```

**名前空間の使い分け:**
- テンプレート: `{% url 'blog:post_list' %}`
- ビュー: `reverse('blog:post_list')` / `reverse_lazy('blog:post_list')`
- リダイレクト: `redirect('blog:post_list')`

---

## 6. Django Generic Views

### 6.1 Generic Viewsとは

Djangoが提供する一般的なWebアプリケーションパターンを簡単に実装できるクラスベースビュー（CBV）。

**公式ドキュメント:**
- https://docs.djangoproject.com/en/stable/topics/class-based-views/
- https://docs.djangoproject.com/en/stable/ref/class-based-views/

### 6.2 主なGeneric Views

| ビュー | 用途 | ドキュメント |
|--------|------|--------------|
| ListView | 一覧表示 | [Link](https://docs.djangoproject.com/en/stable/ref/class-based-views/generic-display/#listview) |
| DetailView | 詳細表示 | [Link](https://docs.djangoproject.com/en/stable/ref/class-based-views/generic-display/#detailview) |
| CreateView | 作成 | [Link](https://docs.djangoproject.com/en/stable/ref/class-based-views/generic-editing/#createview) |
| UpdateView | 更新 | [Link](https://docs.djangoproject.com/en/stable/ref/class-based-views/generic-editing/#updateview) |
| DeleteView | 削除 | [Link](https://docs.djangoproject.com/en/stable/ref/class-based-views/generic-editing/#deleteview) |
| FormView | フォーム処理 | [Link](https://docs.djangoproject.com/en/stable/ref/class-based-views/generic-editing/#formview) |
| TemplateView | テンプレート表示 | [Link](https://docs.djangoproject.com/en/stable/ref/class-based-views/base/#templateview) |

### 6.3 ListView - 一覧表示

```python
class PostListView(ListView):
    model = Post  # 必須
    template_name = 'blog/post_list.html'  # オプション（デフォルト: <app>/<model>_list.html）
    context_object_name = 'posts'  # オプション（デフォルト: object_list）
    paginate_by = 20  # ページネーション
    ordering = ['-created_at']  # 並び順
    
    # オーバーライド可能なメソッド
    def get_queryset(self):
        # クエリセットをカスタマイズ
        return Post.objects.filter(status='published')
    
    def get_context_data(self, **kwargs):
        # コンテキストに追加データを渡す
        context = super().get_context_data(**kwargs)
        context['categories'] = Category.objects.all()
        return context
```

### 6.4 DetailView - 詳細表示

```python
class PostDetailView(DetailView):
    model = Post  # 必須
    template_name = 'blog/post_detail.html'  # オプション
    context_object_name = 'post'  # オプション（デフォルト: object）
    slug_field = 'slug'  # モデルのスラッグフィールド名
    slug_url_kwarg = 'slug'  # URLパターンのキーワード引数名
    
    # または pk_url_kwarg = 'pk' でPK指定も可能
```

### 6.5 CreateView - 作成

```python
class PostCreateView(LoginRequiredMixin, CreateView):
    model = Post  # 必須
    fields = ['title', 'slug', 'content']  # または form_class
    template_name = 'blog/post_form.html'  # オプション
    success_url = reverse_lazy('blog:post_list')  # 必須
    
    # オーバーライド可能なメソッド
    def form_valid(self, form):
        # フォーム送信成功時の処理
        form.instance.author = self.request.user
        return super().form_valid(form)
    
    def form_invalid(self, form):
        # フォーム送信失敗時の処理
        return super().form_invalid(form)
```

**success_url の指定方法（いずれか必須）:**
1. `success_url = reverse_lazy('blog:post_list')`
2. `get_success_url()` メソッドをオーバーライド
3. モデルに `get_absolute_url()` メソッドを定義

**よく使うMixin:**
- `LoginRequiredMixin` - ログイン必須
- `PermissionRequiredMixin` - 権限チェック
- `UserPassesTestMixin` - カスタム条件でアクセス制御

### 6.6 UpdateView - 更新

```python
class PostUpdateView(LoginRequiredMixin, UpdateView):
    model = Post
    fields = ['title', 'content']
    success_url = reverse_lazy('blog:post_list')
    
    def get_queryset(self):
        # 自分の投稿のみ編集可能
        return Post.objects.filter(author=self.request.user)
```

CreateViewとほぼ同じですが、既存オブジェクトを編集します。

### 6.7 DeleteView - 削除

```python
class PostDeleteView(LoginRequiredMixin, DeleteView):
    model = Post
    success_url = reverse_lazy('blog:post_list')
    template_name = 'blog/post_confirm_delete.html'
    
    def get_queryset(self):
        # 自分の投稿のみ削除可能
        return Post.objects.filter(author=self.request.user)
```

---

## まとめ

### セットアップ手順

```bash
cd app/poc

# 1. マイグレーション実行
python manage.py makemigrations blog
python manage.py migrate

# 2. テストデータ投入
python manage.py seed_data --clear

# 3. テスト実行
python manage.py test blog

# 4. 開発サーバー起動
python manage.py runserver
```

### アクセス可能なURL

- `http://localhost:8000/` - トップページ
- `http://localhost:8000/blog/` - 記事一覧
- `http://localhost:8000/blog/<slug>/` - 記事詳細
- `http://localhost:8000/blog/create/` - 記事作成（要ログイン）
- `http://localhost:8000/blog/categories/` - カテゴリ一覧
- `http://localhost:8000/blog/api/posts/` - API（記事一覧JSON）
- `http://localhost:8000/blog/db-check/` - DB接続確認
- `http://localhost:8000/admin/` - 管理画面

### ログイン情報（シーディング後）

- 管理者: `username=admin`, `password=admin123`
- デモ: `username=demo`, `password=demo123`

### 重要なポイント

1. **INSTALLED_APPS への登録必須** - アプリを追加したら必ず settings.py に登録
2. **N+1問題対策** - select_related, prefetch_related を適切に使用
3. **URLの順序** - 固定パスを先に、可変パスを後に
4. **名前空間** - app_name を設定したら `'app_name:url_name'` で参照
5. **Generic Views** - 適切な属性設定とメソッドオーバーライドで柔軟に対応

### 参考リソース

- Django 公式ドキュメント: https://docs.djangoproject.com/
- クラスベースビュー: https://docs.djangoproject.com/en/stable/topics/class-based-views/
- データベースクエリ: https://docs.djangoproject.com/en/stable/topics/db/queries/
- テスト: https://docs.djangoproject.com/en/stable/topics/testing/
- 管理画面: https://docs.djangoproject.com/en/stable/ref/contrib/admin/
