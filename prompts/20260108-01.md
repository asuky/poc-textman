# Django トランザクション・バリデーション・REST API・セッション管理

日付: 2026年1月8日

## 会話の概要

Djangoのトランザクション処理、バリデーション方法、Django REST Frameworkの導入、およびセッション管理について質問と実装を行った。

---

## 質問1: トランザクションの使用について

**ユーザーの質問:**
> 処理について質問ですが、ここトランザクション使用と書いてありますけど @transaction.atomic デコレータをつけると view の処理がトランザクションになるということですか？

**回答:**
はい、その通りです。`@transaction.atomic`デコレータを付けると、その関数全体がデータベーストランザクション内で実行されます。

- **成功時**: 関数内のすべてのDB操作が一括でコミットされる
- **失敗時**: どこかでエラーが発生すると、関数内のすべてのDB操作が自動的にロールバックされる

クラスベースビューでも使用可能：
```python
from django.utils.decorators import method_decorator

class MyView(CreateView):
    @method_decorator(transaction.atomic)
    def form_valid(self, form):
        # この処理がトランザクション内で実行される
        return super().form_valid(form)
```

---

## 質問2: バリデーションの実装方法

**ユーザーの質問:**
> validation はどうすればいいですか。パラメータの存在有無とパターンマッチし、想定外の場合は 400 を返してほしいです。

**実装内容:**
`create_post_with_tags_api`関数に手動バリデーション処理を追加：

- 必須フィールドチェック（`title`, `slug`, `content`）
- パターンマッチ
  - title: 1〜200文字
  - slug: 1〜100文字、小文字英数字とハイフンのみ（正規表現: `^[a-z0-9-]+$`）
  - content: 空でないこと
  - status: `'draft'`または`'published'`のみ
- slug の重複チェック
- tags が配列であることのチェック
- JSON パースエラーのハンドリング

すべてのバリデーションエラーは400ステータスコードで返される。

---

## 質問3: Django推奨のバリデーション方法

**ユーザーの質問:**
> この方法は Django による推奨された方法ですか？
> Django 側に標準で用意されたバリデーションの仕組みは無いのでしょうか？

**回答:**
手動バリデーションは推奨される方法ではありません。Djangoには以下の標準的なバリデーションの仕組みがあります：

### 1. ModelForm（最も推奨）
```python
from django import forms
from .models import Post

class PostAPIForm(forms.ModelForm):
    class Meta:
        model = Post
        fields = ['title', 'slug', 'content', 'status']
    
    def clean_slug(self):
        import re
        slug = self.cleaned_data['slug']
        if not re.match(r'^[a-z0-9-]+$', slug):
            raise forms.ValidationError('Slug can only contain lowercase letters, numbers, and hyphens')
        return slug
```

### 2. Django REST Framework のSerializer（REST API用）
本格的なAPIなら、Django REST Frameworkを使うのが業界標準。

---

## 質問4: Django REST Framework への移行

**ユーザーの質問:**
> Django Rest Framework を使う形に改めてください。
> ただし既存の html template を使う方法も参考にしたいので残し、API 部分のみ修正してください。

**実装内容:**

### 新規作成したファイル

#### 1. `blog/serializers.py`
- `TagSerializer`: タグのシリアライザー
- `CategorySerializer`: カテゴリのシリアライザー
- `PostListSerializer`: 記事一覧用（最小限のフィールド）
- `PostDetailSerializer`: 記事詳細用（関連情報含む）
- `PostCreateSerializer`: 記事作成用（カスタムバリデーション付き）

カスタムバリデーションの実装：
```python
def validate_slug(self, value):
    """slugのカスタムバリデーション"""
    if not re.match(r'^[a-z0-9-]+$', value):
        raise serializers.ValidationError(
            'Slug can only contain lowercase letters, numbers, and hyphens'
        )
    
    if Post.objects.filter(slug=value).exists():
        raise serializers.ValidationError(
            f'Post with slug "{value}" already exists'
        )
    
    return value
```

#### 2. `DRF_GUIDE.md`
Django REST Frameworkの利用ガイドドキュメントを作成：
- 概要と主な特徴
- インストールと設定
- 実装したAPI一覧
- 使い方（ブラウザ、curl、Python）
- バリデーションの仕組み
- トランザクション処理
- HTMLビューとの比較

### 修正したファイル

#### 1. `blog/views.py`
API部分をDRFのクラスベースビューに変更：
- `PostListAPIView`: 記事一覧API（GET）
- `PostDetailAPIView`: 記事詳細API（GET）
- `PostCreateAPIView`: 記事作成API（POST）
- `category_list_api`: カテゴリ一覧API（関数ベース、参考用）

HTMLビュー（`PostListView`、`PostDetailView`など）はそのまま維持。

#### 2. `blog/urls.py`
API URLをDRF版に更新：
```python
# 記事一覧API
path('api/posts/', views.PostListAPIView.as_view(), name='post_list_api'),

# 記事作成API
path('api/posts/create/', views.PostCreateAPIView.as_view(), name='post_create_api'),

# 記事詳細API
path('api/posts/<slug:slug>/', views.PostDetailAPIView.as_view(), name='post_detail_api'),

# カテゴリ一覧API
path('api/categories/', views.category_list_api, name='category_list_api'),
```

#### 3. `settings.py`
- `INSTALLED_APPS`に`'rest_framework'`を追加
- `REST_FRAMEWORK`設定を追加：
  - 認証クラス（SessionAuthentication、BasicAuthentication）
  - 権限クラス（IsAuthenticatedOrReadOnly）
  - ページネーション（20件/ページ）
  - レンダラー（JSON、BrowsableAPI）
  - パーサー（JSON、Form、MultiPart）

#### 4. `pyproject.toml`
依存関係に`djangorestframework>=3.15.0`を追加

### DRFのメリット
1. ✅ 自動バリデーション: 手動チェック不要
2. ✅ 標準化: 業界標準のRESTful API設計
3. ✅ セキュリティ: 組み込みの認証・権限管理
4. ✅ テストしやすい: Serializerを独立してテスト可能
5. ✅ メンテナンス性: コードが簡潔で理解しやすい

### トランザクション処理
DRFのGeneric Viewsは、**デフォルトで`@transaction.atomic`が適用されている**ため、明示的に指定する必要はありません。

---

## 質問5: Browsable APIとJSON形式

**ユーザーの質問:**
> この @api_view の GET で html のサイトが見えるのですが JSON にはならないんですか？

**回答:**
それはDRFの**「Browsable API」**という機能です。ブラウザでアクセスすると自動的にHTMLのUIが表示されます。

### JSON形式で取得する方法

1. **URLに`?format=json`を追加**
   ```
   http://localhost:8000/blog/api/categories/?format=json
   ```

2. **curlでアクセス**
   ```bash
   curl http://localhost:8000/blog/api/categories/
   ```
   コマンドラインからアクセスすると自動的にJSONが返る

3. **Acceptヘッダーを指定**
   ```bash
   curl -H "Accept: application/json" http://localhost:8000/blog/api/categories/
   ```

### 常にJSONだけ返す場合
`settings.py`の`REST_FRAMEWORK`設定から`BrowsableAPIRenderer`を削除。

**推奨**: 開発中は両方有効（現在の設定のまま）がおすすめ。本番環境では`BrowsableAPIRenderer`を削除してJSONのみにするのが一般的。

---

## 質問6: セッションの保存場所と変更方法

**ユーザーの質問:**
> ユーザの認証機能があるのですが、Django の場合はサーバーセッションをどこに保存しているんですか？
> 保存している場所を変更する（例えば Redis とかに）方法はあったりしますか？

**回答:**

### デフォルトのセッション保存場所
Djangoのセッションは**デフォルトでデータベースに保存**されています。

```python
# 設定ファイルに何も書かない場合（デフォルト）
SESSION_ENGINE = 'django.contrib.sessions.backends.db'
```

セッションは`django_session`テーブルに保存されます。

### 利用可能なバックエンド

| バックエンド | 説明 | 設定値 |
|------------|------|--------|
| **Database** | データベース（デフォルト） | `django.contrib.sessions.backends.db` |
| **Cache** | キャッシュ（Redis/Memcached） | `django.contrib.sessions.backends.cache` |
| **Cached DB** | キャッシュ+DB（推奨） | `django.contrib.sessions.backends.cached_db` |
| **File** | ファイルシステム | `django.contrib.sessions.backends.file` |
| **Cookie** | クライアント側（暗号化） | `django.contrib.sessions.backends.signed_cookies` |

### Redisに変更する方法

#### 1. パッケージのインストール
```toml
# pyproject.toml
dependencies = [
    "django>=6.0",
    "djangorestframework>=3.15.0",
    "redis>=5.0.0",
    "django-redis>=5.4.0",
]
```

#### 2. Redis起動（Docker）
```yaml
# compose.yaml
services:
  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    command: redis-server --appendonly yes

volumes:
  redis_data:
```

#### 3. settings.py の設定
```python
# キャッシュ設定（Redis）
CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': 'redis://127.0.0.1:6379/1',
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
            'CONNECTION_POOL_KWARGS': {'max_connections': 50},
        }
    }
}

# セッション設定（推奨: Cached DB）
SESSION_ENGINE = 'django.contrib.sessions.backends.cached_db'
SESSION_CACHE_ALIAS = 'default'
```

### 各バックエンドの比較

| 特徴 | Database | Cache | Cached DB | File | Cookie |
|------|----------|-------|-----------|------|--------|
| **速度** | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ⭐ | ⭐⭐⭐⭐⭐ |
| **永続性** | ✅ | ❌ | ✅ | ✅ | ❌ |
| **スケール** | ⭐⭐ | ⭐⭐⭐⭐⭐ | ⭐⭐⭐⭐ | ❌ | ⭐⭐⭐⭐⭐ |
| **複数サーバー** | ✅ | ✅ | ✅ | ❌ | ✅ |
| **推奨環境** | 小規模 | 中規模 | **本番** | テスト | API |

### 推奨設定
- **開発環境**: Database（デフォルト）
- **本番環境**: **Cached DB + Redis**（速度と安全性のバランス）
- **高トラフィック**: Cache + Redis（速度優先）
- **API専用**: Signed Cookies（ステートレス）

### 新規作成したドキュメント
`SESSION_GUIDE.md`: セッション管理の完全ガイドを作成
- デフォルトのセッション保存場所
- 利用可能なバックエンド詳細
- Redisへの移行手順
- 各バックエンドの比較表
- セッション設定項目一覧
- 管理コマンド
- トラブルシューティング

---

## 質問7: インストールコマンド

**ユーザーの質問:**
> インストールのコマンド実施はこちらでやるのですが、uv sync で良いです？他のコマンドが必要ですか？

**回答:**
はい、`uv sync`で大丈夫です。

```powershell
cd app
uv sync
```

これで`djangorestframework`がインストールされます。

### その後の確認手順

1. **サーバーを再起動**（設定変更を反映）
   ```powershell
   cd poc
   python manage.py runserver
   ```

2. **ブラウザでAPIをテスト**
   - 記事一覧API: http://localhost:8000/blog/api/posts/
   - カテゴリAPI: http://localhost:8000/blog/api/categories/

3. **動作確認**
   ブラウザでアクセスすると、DRFのWeb UIが表示され、GUIでAPIをテストできます。

マイグレーションは不要（モデル変更がないため）。

---

## 成果物

### 新規作成
1. `app/poc/blog/serializers.py` - DRF Serializerクラス
2. `app/poc/DRF_GUIDE.md` - Django REST Framework利用ガイド
3. `app/poc/SESSION_GUIDE.md` - セッション管理ガイド

### 修正
1. `app/poc/blog/views.py` - API部分をDRFに移行、HTMLビューは維持
2. `app/poc/blog/urls.py` - API URLをDRF版に更新
3. `app/poc/poc/settings.py` - DRF設定追加
4. `app/pyproject.toml` - djangorestframework依存関係追加

---

## 学んだこと

1. **トランザクション**: `@transaction.atomic`デコレータで関数全体をトランザクション化、DRFはデフォルトで適用済み
2. **バリデーション**: 手動実装より、DRFのSerializerによる自動バリデーションが推奨
3. **REST API**: Django REST Frameworkが業界標準、自動バリデーション・認証・ドキュメント生成などの機能
4. **セッション**: デフォルトはDB保存、本番環境ではRedis + Cached DBが推奨
5. **Browsable API**: DRFはブラウザでGUIテスト可能、`?format=json`で純粋なJSONも取得可能
